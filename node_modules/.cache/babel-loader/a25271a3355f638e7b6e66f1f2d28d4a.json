{"ast":null,"code":"var _jsxFileName = \"G:\\\\GithubWebsite\\\\portfoliowebsite\\\\src\\\\components\\\\CharterProject.js\";\nimport React from 'react';\nimport { createDbWorker } from \"sql.js-httpvfs\";\n\nclass CharterProject extends React.Component {\n  constructor(props) {\n    super(props);\n    this.loadDatabase();\n  }\n\n  async loadDatabase() {\n    // sadly there's no good way to package workers and wasm directly so you need a way to get these two URLs from your bundler.\n    // This is the webpack5 way to create a asset bundle of the worker and wasm:\n    const workerUrl = new URL(\"sql.js-httpvfs/dist/sqlite.worker.js\", import.meta.url);\n    const wasmUrl = new URL(\"sql.js-httpvfs/dist/sql-wasm.wasm\", import.meta.url); // the legacy webpack4 way is something like `import wasmUrl from \"file-loader!sql.js-httpvfs/dist/sql-wasm.wasm\"`.\n    // the config is either the url to the create_db script, or a inline configuration:\n\n    const config = {\n      from: \"inline\",\n      config: {\n        serverMode: \"full\",\n        // file is just a plain old full sqlite database\n        requestChunkSize: 4096,\n        // the page size of the  sqlite database (by default 4096)\n        url: \"/foo/bar/test.sqlite3\" // url to the database (relative or full)\n\n      }\n    }; // or:\n    // const config = {\n    //   from: \"jsonconfig\",\n    //   configUrl: \"/foo/bar/config.json\"\n    // }\n\n    const worker = await createDbWorker([config], workerUrl.toString(), wasmUrl.toString()); // you can also pass multiple config objects which can then be used as separate database schemas with `ATTACH virtualFilename as schemaname`, where virtualFilename is also set in the config object.\n    // worker.db is a now SQL.js instance except that all functions return Promises.\n\n    const result = await worker.db.exec(`select * from table where id = ?`, [123]);\n    const sqlPromise = initSqlJs({\n      locateFile: file => 'https://github.com/BrettSchlereth/CharterHW/blob/main/transactionSQL.sqlite'\n    });\n    const dataPromise = fetch(\"/path/to/database.sqlite\").then(res => res.arrayBuffer());\n    const [SQL, buf] = await Promise.all([sqlPromise, dataPromise]);\n    const db = new SQL.Database(new Uint8Array(buf));\n  }\n\n  render() {\n    return /*#__PURE__*/React.createElement(\"div\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 62,\n        columnNumber: 7\n      }\n    }, \"returned from script\");\n  }\n\n}\n\nexport default CharterProject;","map":{"version":3,"sources":["G:/GithubWebsite/portfoliowebsite/src/components/CharterProject.js"],"names":["React","createDbWorker","CharterProject","Component","constructor","props","loadDatabase","workerUrl","URL","import","meta","url","wasmUrl","config","from","serverMode","requestChunkSize","worker","toString","result","db","exec","sqlPromise","initSqlJs","locateFile","file","dataPromise","fetch","then","res","arrayBuffer","SQL","buf","Promise","all","Database","Uint8Array","render"],"mappings":";AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,SAASC,cAAT,QAA+B,gBAA/B;;AAEA,MAAMC,cAAN,SAA6BF,KAAK,CAACG,SAAnC,CAA6C;AAE3CC,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACjB,UAAMA,KAAN;AACA,SAAKC,YAAL;AAED;;AAED,QAAMA,YAAN,GAAqB;AACf;AACJ;AACA,UAAMC,SAAS,GAAG,IAAIC,GAAJ,CAChB,sCADgB,EAEhBC,MAAM,CAACC,IAAP,CAAYC,GAFI,CAAlB;AAIA,UAAMC,OAAO,GAAG,IAAIJ,GAAJ,CACd,mCADc,EAEdC,MAAM,CAACC,IAAP,CAAYC,GAFE,CAAhB,CAPmB,CAWnB;AAEA;;AACA,UAAME,MAAM,GAAG;AACbC,MAAAA,IAAI,EAAE,QADO;AAEbD,MAAAA,MAAM,EAAE;AACNE,QAAAA,UAAU,EAAE,MADN;AACc;AACpBC,QAAAA,gBAAgB,EAAE,IAFZ;AAEkB;AACxBL,QAAAA,GAAG,EAAE,uBAHC,CAGuB;;AAHvB;AAFK,KAAf,CAdmB,CAsBnB;AACA;AACA;AACA;AACA;;AAEA,UAAMM,MAAM,GAAG,MAAMhB,cAAc,CACjC,CAACY,MAAD,CADiC,EAEjCN,SAAS,CAACW,QAAV,EAFiC,EAEXN,OAAO,CAACM,QAAR,EAFW,CAAnC,CA5BmB,CAgCnB;AAGA;;AAEA,UAAMC,MAAM,GAAG,MAAMF,MAAM,CAACG,EAAP,CAAUC,IAAV,CAAgB,kCAAhB,EAAmD,CAAC,GAAD,CAAnD,CAArB;AAGA,UAAMC,UAAU,GAAGC,SAAS,CAAC;AAACC,MAAAA,UAAU,EAAEC,IAAI,IAAI;AAArB,KAAD,CAA5B;AACA,UAAMC,WAAW,GAAGC,KAAK,CAAC,0BAAD,CAAL,CAAkCC,IAAlC,CAAuCC,GAAG,IAAIA,GAAG,CAACC,WAAJ,EAA9C,CAApB;AACA,UAAM,CAACC,GAAD,EAAMC,GAAN,IAAa,MAAMC,OAAO,CAACC,GAAR,CAAY,CAACZ,UAAD,EAAaI,WAAb,CAAZ,CAAzB;AACA,UAAMN,EAAE,GAAG,IAAIW,GAAG,CAACI,QAAR,CAAiB,IAAIC,UAAJ,CAAeJ,GAAf,CAAjB,CAAX;AACD;;AAIDK,EAAAA,MAAM,GAAG;AACP,wBACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,8BADF;AAID;;AA7D0C;;AAgE7C,eAAenC,cAAf","sourcesContent":["import React from 'react';\r\nimport { createDbWorker } from \"sql.js-httpvfs\"\r\n\r\nclass CharterProject extends React.Component {\r\n\r\n  constructor(props) {\r\n    super(props);\r\n    this.loadDatabase()\r\n\r\n  }\r\n\r\n  async loadDatabase() {\r\n        // sadly there's no good way to package workers and wasm directly so you need a way to get these two URLs from your bundler.\r\n    // This is the webpack5 way to create a asset bundle of the worker and wasm:\r\n    const workerUrl = new URL(\r\n      \"sql.js-httpvfs/dist/sqlite.worker.js\",\r\n      import.meta.url,\r\n    );\r\n    const wasmUrl = new URL(\r\n      \"sql.js-httpvfs/dist/sql-wasm.wasm\",\r\n      import.meta.url,\r\n    );\r\n    // the legacy webpack4 way is something like `import wasmUrl from \"file-loader!sql.js-httpvfs/dist/sql-wasm.wasm\"`.\r\n\r\n    // the config is either the url to the create_db script, or a inline configuration:\r\n    const config = {\r\n      from: \"inline\",\r\n      config: {\r\n        serverMode: \"full\", // file is just a plain old full sqlite database\r\n        requestChunkSize: 4096, // the page size of the  sqlite database (by default 4096)\r\n        url: \"/foo/bar/test.sqlite3\" // url to the database (relative or full)\r\n      }\r\n    };\r\n    // or:\r\n    // const config = {\r\n    //   from: \"jsonconfig\",\r\n    //   configUrl: \"/foo/bar/config.json\"\r\n    // }\r\n\r\n    const worker = await createDbWorker(\r\n      [config],\r\n      workerUrl.toString(), wasmUrl.toString()\r\n    );\r\n    // you can also pass multiple config objects which can then be used as separate database schemas with `ATTACH virtualFilename as schemaname`, where virtualFilename is also set in the config object.\r\n\r\n\r\n    // worker.db is a now SQL.js instance except that all functions return Promises.\r\n\r\n    const result = await worker.db.exec(`select * from table where id = ?`, [123]);\r\n\r\n\r\n    const sqlPromise = initSqlJs({locateFile: file => 'https://github.com/BrettSchlereth/CharterHW/blob/main/transactionSQL.sqlite'});\r\n    const dataPromise = fetch(\"/path/to/database.sqlite\").then(res => res.arrayBuffer());\r\n    const [SQL, buf] = await Promise.all([sqlPromise, dataPromise])\r\n    const db = new SQL.Database(new Uint8Array(buf));\r\n  }\r\n\r\n\r\n\r\n  render() {\r\n    return(\r\n      <div>\r\n        returned from script\r\n      </div>)\r\n  }\r\n}\r\n\r\nexport default CharterProject;\r\n"]},"metadata":{},"sourceType":"module"}